/*!
 * @maptalks/gltf-loader v0.27.1
 * LICENSE : UNLICENSED
 * (c) 2016-2022 maptalks.org
 */
import{quat as e,mat4 as t,vec3 as s,vec4 as r}from"gl-matrix";let n=0;function i(e){return null==e}function a(e){return!i(e)}function o(e){for(let t=1;t<arguments.length;t++){const s=arguments[t];for(const t in s)e[t]=s[t]}return e}function f(e){switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array}throw new Error("unsupported bufferView's component type: "+e)}function u(e){return 0===e.indexOf("data:")&&e.indexOf("base64,")>0}function h(e){const t=function(e){return"undefined"!=typeof self?self.atob(e):window.atob(e)}(e.substring(e.indexOf(",")+1)),s=t.length,r=new Uint8Array(s);for(let e=0;e<s;e++)r[e]=t.charCodeAt(e);return r.buffer}const c=[],l=[],m=[],d=[0,0,0],g=e.identity([]),p=[1,1,1];function b(e,t,s,r,n,i,a){const o=f(a);if((0===n||n===r*o.BYTES_PER_ELEMENT)&&i%o.BYTES_PER_ELEMENT==0){const n=new o(t,i,s*r);return e.set(n),e}0===n&&(n=r*o.BYTES_PER_ELEMENT);const u=new Uint8Array(r*o.BYTES_PER_ELEMENT);for(let a=0;a<s;a++){let s=null;const f=new Uint8Array(t,n*a+i,r*o.BYTES_PER_ELEMENT);u.set(f),s=new o(u.buffer,0,r);for(let t=0;t<r;t++)e[a*r+t]=s[t]}return e}const y="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;function _(e,t,s){const r=new Uint8Array(e,t,s);return y.decode(r)}const w={get:function(e,t={}){t||(t={});const s=new AbortController,r=s.signal,n=o({},t);n.signal=r,n.method||(n.method="GET");const i=fetch(e,n).then(e=>{const s=this._parseResponse(e,t.responseType);return s.message?s:s.then(s=>"arraybuffer"===t.responseType?{data:s,cacheControl:e.headers.get("Cache-Control"),expires:e.headers.get("Expires"),contentType:e.headers.get("Content-Type")}:s).catch(e=>{if(!e.code||e.code!==DOMException.ABORT_ERR)throw e})}).catch(e=>{if(!e.code||e.code!==DOMException.ABORT_ERR)throw e});return i.xhr=s,i},_parseResponse:(e,t)=>200!==e.status?{status:e.status,statusText:e.statusText,message:`incorrect http request with status code(${e.status}): ${e.statusText}`}:"arraybuffer"===t?e.arrayBuffer():"json"===t?e.json():e.text(),getArrayBuffer:(e,t={})=>(t||(t={}),t.responseType="arraybuffer",w.get(e,t)),getJSON:function(e,t={}){return t&&t.jsonp?w.jsonp(e):((t=t||{}).responseType="json",w.get(e,t))}};w.jsonp=function(e){const t="_maptalks_jsonp_"+n++;e.match(/\?/)?e+="&callback="+t:e+="?callback="+t;let s=document.createElement("script");return s.type="text/javascript",s.src=e,new Promise(e=>{window[t]=function(r){document.getElementsByTagName("head")[0].removeChild(s),s=null,delete window[t],e(r)},document.getElementsByTagName("head")[0].appendChild(s)})};class x{constructor(e,t,s){this._requestImage=e,this.decoders=t,this._supportedFormats=s,this.images={},this._imgRequests={}}requestImageFromBufferURI(e,t,s){if(this.buffers[e.id]){const r=this.buffers[e.id],n=this._createDataView(t,r);return this.getImageByBuffer(n,s)}if(this._imgRequests[e.id])return this._imgRequests[e.id].then(()=>{const r=this.buffers[e.id],n=this._createDataView(t,r);return this.getImageByBuffer(n,s)});if(u(e.uri)){const r=this.buffers[e.id]=h(e.uri),n=this._createDataView(t,r);return this.getImageByBuffer(n,s)}return this._imgRequests[e.id]=w.getArrayBuffer(e.uri,null).then(r=>{const n=this.buffers[e.id]=r.data,i=this._createDataView(t,n);return this.getImageByBuffer(i,s)})}getImageByBuffer(e,t){if(this.images[t.id])return Promise.resolve(this.images[t.id]);const s=this.decoders;if(s[t.mimeType])return s[t.mimeType](e,{supportedFormats:this._supportedFormats});if("image/crn"===t.mimeType||"image/ktx2"===t.mimeType||"image/cttf"===t.mimeType)return console.warn("missing transcoder for "+t.mimeType,", visit https://maptalks.com/docs/transcoders for details"),Promise.resolve(null);{const s=new Blob([e],{type:t.mimeType}),r=URL.createObjectURL(s);return this._getImageInfo(t.id,r)}}requestExternalImage(e){if(this.images[e.id])return Promise.resolve(this.images[e.id]);const t=0===e.uri.indexOf("data:image/")?e.uri:this.rootPath+"/"+e.uri;if(this._imgRequests[e.id])return this._imgRequests[e.id].then(()=>this.images[e.id]);return this._imgRequests[e.id]=this._getImageInfo(e.id,t)}_getImageInfo(e,t){return new Promise((s,r)=>{this._requestImage(t,(n,i)=>{n?r(n):(URL.revokeObjectURL(t),this.images[e]=i,s(this.images[e]))})})}}const T=["SCALAR",1,"VEC2",2,"VEC3",3,"VEC4",4,"MAT2",4,"MAT3",9,"MAT4",16];class E{constructor(e,t,s){this.rootPath=e,this.gltf=t,this._enableInterleave=!1,this.glbBuffer=s,this.buffers={},this.requests={},this.accessors={},this._compareAccessor()}_requestData(e,t){const s=this.gltf,r=s.accessors[t];if(void 0===r.bufferView)return this.accessors[r.id]=this._toBufferData(e,t,null,0),Promise.resolve(this.accessors[r.id]);if(r&&this.accessors[r.id])return Promise.resolve(this.accessors[r.id]);const n=s.bufferViews[r.bufferView];return this._requestBufferOfBufferView(n).then(s=>{const{buffer:n,byteOffset:i}=s;return this.accessors[r.id]=this._toBufferData(e,t,n,i)})}_requestBufferOfBufferView(e){const t=this.gltf.buffers[e.buffer];if(this.buffers[t.id]){const e=this.buffers[t.id];return Promise.resolve({buffer:e,byteOffset:0})}if(this.requests[t.id])return this.requests[t.id].then(()=>{const e=this.buffers[t.id];return Promise.resolve({buffer:e,byteOffset:0})});if("binary_glTF"!==e.buffer&&"KHR_binary_glTF"!==e.buffer&&t.uri){if(u(t.uri)){const e=this.buffers[t.id]=h(t.uri);return Promise.resolve({buffer:e,byteOffset:0})}let e;const s=t.uri.indexOf("blob:")>=0;e=t.uri.indexOf("://")>0||s?t.uri:this.rootPath+"/"+t.uri;return this.requests[t.id]=w.getArrayBuffer(e,null).then(r=>{s&&URL.revokeObjectURL(e);return{buffer:this.buffers[t.id]=r.data,byteOffset:0}})}return Promise.resolve({buffer:this.glbBuffer.buffer,byteOffset:this.glbBuffer.byteOffset})}_toBufferData(e,t,s,r=0){const n=this.gltf,i=n.accessors[t],a=void 0!==i.bufferView?n.bufferViews[i.bufferView]:{},o=(a.byteOffset||0)+r,u=this._getTypeItemSize(i.type),h=f(i.componentType),c=a.byteStride||0;const l={array:void 0,name:e,accessorName:t,byteLength:i.count*u*h.BYTES_PER_ELEMENT,componentType:i.componentType,count:i.count,type:i.type,itemSize:u};if(i.min&&(l.min=i.min),i.max&&(l.max=i.max),s)if(this._enableInterleave)l.byteStride=c,l.byteOffset=o+(i.byteOffset||0),!c||c===u*h.BYTES_PER_ELEMENT||"indices"===e||"input"===e||"output"===e||e.indexOf("morph")>=0?(l.array=this._typedArray(s,i.count,u,o+(i.byteOffset||0),h),l.array.buffer.byteLength===l.byteLength&&(l.byteOffset=0)):l.array=new Uint8Array(s,o,a.byteLength);else if(i.interleaved){l.byteStride=0,l.byteOffset=0;const e=new h(i.count*u);l.array=b(e,s,i.count,u,c,o+(i.byteOffset||0),i.componentType)}else l.byteStride=0,l.array=this._typedArray(s,i.count,u,o+(i.byteOffset||0),h),l.byteOffset=l.array.byteOffset;else{l.array=new h(i.count);const e=l.min||l.max;e&&(l.array[0]=e[0],l.array[1]=e[1],l.array[2]=e[2])}return l}_compareAccessor(){const e=this.gltf.accessors;if(Array.isArray(e))for(let t=0;t<e.length;t++)for(let s=0;s<e.length;s++)t!==s&&e[t].bufferView===e[s].bufferView&&(e[t].interleaved=e[s].interleaved=!0);else for(const t in e)for(const s in e)t!==s&&e[t].bufferView===e[s].bufferView&&(e[t].interleaved=e[s].interleaved=!0)}_typedArray(e,t,s,r,n){return r%n.BYTES_PER_ELEMENT!=0&&(e=e.slice(r,r+t*s*n.BYTES_PER_ELEMENT),r=0),new n(e,r,s*t)}_getTypeItemSize(e){const t=T.indexOf(e);return T[t+1]}requestKHRTechniquesWebgl(e){const{shaders:t}=e,s=t.map(e=>{if(void 0!==e.bufferView){const t=this.gltf.bufferViews[e.bufferView],{byteLength:s}=t;return this._requestBufferOfBufferView(t).then(r=>{const{buffer:n,byteOffset:i}=r,a=_(n,i+(t.byteOffset||0),s);return e.content=a,e})}if(e.uri){if(u(e.uri)){const t=h(e.uri),s=_(t,0,t.byteLength);return e.content=s,Promise.resolve(e)}{const t=this.rootPath+"/"+e.uri;return w.get(t).then(t=>(e.content=t,e))}}return Promise.resolve(e)});return Promise.all(s).then(()=>e)}}class I extends x{constructor(e,t,s,r,n,i){super(r,n,i),this.rootPath=e,this.gltf=t,this.requests={},this.buffers={},this.glbBuffer=s,this.accessor=new E(e,t,s)}iterate(e,t){const s=this.gltf[t];if(!s)return;let r=0;for(const t in s)e(t,s[t],r++)}createNode(e){const s={};if(a(e.name)&&(s.name=e.name),a(e.children)&&(s.children=e.children),a(e.jointName)&&(s.jointName=e.jointName),a(e.matrix)&&(s.matrix=e.matrix),a(e.rotation)&&(s.rotation=e.rotation),a(e.scale)&&(s.scale=e.scale),a(e.translation)&&(s.translation=e.translation),a(e.extras)&&(s.extras=e.extras),a(e.meshes)&&(s.mesh=e.meshes[0]),s.translation||s.rotation||s.scale){const e=function(e,s){if(s.matrix)return s.matrix;if(s.translation||s.scale||s.rotation){const r=t.fromTranslation(c,s.translation||d),n=t.fromQuat(l,s.rotation||g),i=t.fromScaling(m,s.scale||p);return t.multiply(i,n,i),t.multiply(e,r,i)}return t.identity(e)}([],s);delete s.translation,delete s.rotation,delete s.scale,s.matrix=e}return s}_loadMaterials(e){const t={};for(const s in e){const r=e[s];let n,i;r.instanceTechnique&&r.instanceTechnique.values?(n=r.instanceTechnique,i=n.values.diffuse):(n=r,i=n.values.tex||n.values.diffuseTex||n.values.diffuse);const a={baseColorTexture:{index:i}};r.name&&(a.name=r.name),r.extensions&&(a.extensions=r.extensions),r.extras&&(a.extras=r.extras),t[s]=a}return t}_loadImage(e){if(e.bufferView||e.extensions&&(e.extensions.KHR_binary_glTF||e.extensions.binary_glTF)){const t=e.bufferView?e:e.extensions.KHR_binary_glTF||e.extensions.binary_glTF;e.extensions&&(e.mimeType=t.mimeType,e.width=t.width,e.height=t.height);const s=this.gltf.bufferViews[t.bufferView],r=(s.byteOffset||0)+this.glbBuffer.byteOffset,n=s.byteLength,i=this.buffers[t.bufferView]=new Uint8Array(this.glbBuffer.buffer,r,n);return this.getImageByBuffer(i,e)}return this.requestExternalImage(e)}_getTexture(e){const t=this.gltf.textures[e];if(!t)return null;const s=this.gltf.images[t.source];return this._loadImage(s).then(e=>{const r=this.gltf.samplers[t.sampler];return{image:{array:e.data,width:e.width,height:e.height,index:t.source,mimeType:s.mimeType,name:s.name,extras:s.extras},sampler:r}})}getBaseColorTexture(e){const t=this.gltf.materials[e];let s,r;if(t.instanceTechnique&&t.instanceTechnique.values?(s=t.instanceTechnique,r=s.values.diffuse):(s=t,r=s.values.tex||s.values.diffuseTex||s.values.diffuse),void 0===r||void 0===this.gltf.textures)return null;const n=this.gltf.textures[r];if(!n)return null;const i=this.gltf.samplers[n.sampler];return{format:n.format||6408,internalFormat:n.internalFormat||6408,type:n.type||5121,sampler:i,source:this.gltf.images[n.source]}}getMaterial(){return null}getAnimations(){return null}}class O extends x{constructor(e,t,s,r,n,i){super(r,n,i),this.rootPath=e,this.gltf=t,this.glbBuffer=s,this.buffers={},this.requests={},this.accessor=new E(e,t,s)}iterate(e,t){const s=this.gltf[t];if(s)for(let t=0;t<s.length;t++)e(t,s[t],t)}createNode(e){const t={};return o(t,e),!a(e.weights)&&this.gltf.meshes&&a(t.mesh)?t.weights=this.gltf.meshes[t.mesh].weights:e.weights&&(t.weights=e.weights),t}_getTexture(e){const t=this.gltf.textures[e];if(!t)return null;const s=this.gltf.images[t.source];return this._loadImage(s).then(e=>{if(!e)return null;const r={image:{array:e.data,mipmap:e.mipmap,width:e.width,height:e.height,index:t.source,mimeType:s.mimeType,name:s.name,extensions:s.extensions,extras:s.extras}};o(r,t);const n=a(t.sampler)?this.gltf.samplers[t.sampler]:void 0;return n&&(r.sampler=n),e.format&&(r.format=e.format),r})}_loadImage(e){if(!a(e.bufferView))return this.requestExternalImage(e);{const t=this.gltf.bufferViews[e.bufferView],s=this.gltf.buffers[t.buffer];if(s.uri)return this.requestImageFromBufferURI(s,t,e);if(this.glbBuffer)return this._requestFromGlbBuffer(t,e)}return null}_requestFromGlbBuffer(e,t){const s=this._createDataView(e,this.glbBuffer.buffer,this.glbBuffer.byteOffset);return this.getImageByBuffer(s,t)}_createDataView(e,t,s){s=s||0;const r=e.byteOffset+s,n=e.byteLength;return new Uint8Array(t,r,n)}_transformArrayBufferToBase64(e,t){const s=new Array(e.byteLength);for(let t=0;t<e.byteLength;t++)s[t]=String.fromCharCode(e[t]);s.join("");return"data:"+(t=t||"image/png")+";base64,"+function(e){return"undefined"!=typeof self?self.btoa(e):window.btoa(e)}(unescape(encodeURIComponent(s)))}getAnimations(e){const t=[];return e.forEach(e=>{t.push(this.getSamplers(e.samplers))}),Promise.all(t).then(t=>{for(let s=0;s<t.length;s++)e[s].samplers=t[s];return e})}getSamplers(e){const t=[];for(let s=0;s<e.length;s++)(a(e[s].input)||a(e[s].output))&&(t.push(this.accessor._requestData("input",e[s].input)),t.push(this.accessor._requestData("output",e[s].output)));return Promise.all(t).then(t=>{for(let s=0;s<t.length/2;s++)e[s].input=t[2*s],e[s].output=t[2*s+1],e[s].interpolation||(e[s].interpolation="LINEAR");return e})}}const R="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null,N=1313821514,B=5130562;class A{static read(e,t=0,s=0){s||(s=e.byteLength);const r=new DataView(e,t,s),n=r.getUint32(4,!0);if(1===n)return A.readV1(r,t);if(2===n)return A.readV2(e,t);throw new Error("Unsupported glb version : "+n)}static readV1(e,t){const s=e.getUint32(8,!0),r=e.getUint32(12,!0);if(s!==e.byteLength)throw new Error("Length in GLB header is inconsistent with glb's byte length.");const n=P(e.buffer,20+t,r);return{json:JSON.parse(n),glbBuffer:{byteOffset:20+t+r,buffer:e.buffer,byteLength:s}}}static readV2(e,t){let s,r,n;const i=new DataView(e,t+12);let a=0;for(;a<i.byteLength;){const o=i.getUint32(a,!0);a+=4;const f=i.getUint32(a,!0);if(a+=4,f===N)s=P(e,t+12+a,o);else if(f===B){n=t+12+a,r=o;break}a+=o}return{json:JSON.parse(s),glbBuffer:{byteOffset:n,buffer:e,byteLength:r}}}}function P(e,t,s){if(R){const r=new Uint8Array(e,t,s);return R.decode(r)}return function(e){const t=e.length;let s="";for(let r=0;r<t;){let n=e[r++];if(128&n){let s=S[n>>3&7];if(!(64&n)||!s||r+s>t)return null;for(n&=63>>s;s>0;s-=1){const t=e[r++];if(128!=(192&t))return null;n=n<<6|63&t}}s+=String.fromCharCode(n)}return s}(new Uint8Array(e,t,s))}const S=[1,1,1,1,2,2,3,0];const v=[0,0,0],q=[0,0,0,1],V=[1,1,1],M={TRANSLATION:[0,0,0],ROTATION:[0,0,0,1],SCALE:[1,1,1]},L={PREVIOUS:null,NEXT:null,PREINDEX:null,NEXTINDEX:null,INTERPOLATION:null},U={_getTRSW(t,r,n,i,o,f,u,h){const c=a(t)?r.animations:[r.animations[0]],l={};for(let r=0;r<c.length;r++){const m=c[r],d=m.name||r;if(a(t)&&d!==t)continue;const g=m.channelsMap[n];if(g)for(let t=0;t<g.length;t++){const r=g[t];"translation"===r.target.path?(this._getAnimateData(o,m.samplers[r.sampler],i,1),l.translation=s.copy(v,o)):"rotation"===r.target.path?(this._getQuaternion(f,m.samplers[r.sampler],i,1),l.rotation=e.copy(q,f)):"scale"===r.target.path?(this._getAnimateData(u,m.samplers[r.sampler],i,1),l.scale=s.copy(V,u)):"weights"===r.target.path&&h&&(this._getAnimateData(h,m.samplers[r.sampler],i,h.length),l.weights=h)}}return l},_getAnimateData(e,t,s,r){switch(t.interpolation){case"LINEAR":{const n=this._getPreNext(L,t,s,1*r);n&&(e=function(e,t,s,r){for(let n=0;n<e.length;n++)e[n]=t[n]+r*(s[n]-t[n]);return e}(e,n.PREVIOUS,n.NEXT,n.INTERPOLATION));break}case"STEP":{const n=this._getPreNext(L,t,s,1*r);n&&(e=function(e,t){for(let s=0;s<e.length;s++)e[s]=t[s];return e}(e,...n.PREVIOUS));break}case"CUBICSPLINE":{const n=this._getPreNext(L,t,s,3*r);n&&(e=this._getCubicSpline(e,n,t.input.array,3*r));break}}return e},_getQuaternion(t,s,n){switch(s.interpolation){case"LINEAR":{const r=this._getPreNext(L,s,n,1);r&&e.slerp(t,r.PREVIOUS,r.NEXT,r.INTERPOLATION);break}case"STEP":{const e=this._getPreNext(L,s,n,1);e&&(t=r.set(t,...e.PREVIOUS));break}case"CUBICSPLINE":{const e=this._getPreNext(L,s,n,3);if(e){for(let t=0;t<e.PREVIOUS.length;t++)e.PREVIOUS[t]=Math.acos(e.PREVIOUS[t]),e.NEXT[t]=Math.acos(e.NEXT[t]);t=this._getCubicSpline(t,e,s.input.array,3);for(let e=0;e<t.length;e++)t[e]=Math.cos(t[e])}break}}return t},_search(e,t){const s=e.length;let r,n,i,a=0,o=s-1,f=Math.floor((a+o)/2);for(;a<=s-1&&o>=0;){if(a===o)return null;if(e[f]<=t&&t<=e[f+1]){const s=e[f];return r=f,n=f+1,i=(t-s)/(e[f+1]-s),{preIndx:r,nextIndex:n,interpolation:i}}t<e[f]?(o=f,f=Math.floor((a+o)/2)):e[f+1]<t&&(a=f,f=Math.floor((a+o)/2))}return null},_getPreNext(e,t,s,r){const n=t.input.array,i=t.output.array,a=t.output.itemSize;(s<n[0]||s>n[n.length-1])&&(s=Math.max(n[0],Math.min(n[n.length-1],s))),s===n[n.length-1]&&(s=n[0]);const o=this._search(n,s);if(!o||!o.nextIndex)return null;const{preIndx:f,nextIndex:u,interpolation:h}=o;e.PREINDEX=f,e.NEXTINDEX=u,e.INTERPOLATION=h;const c=a*r;return e.PREVIOUS=i.subarray(e.PREINDEX*c,(e.PREINDEX+1)*c),e.NEXT=i.subarray(e.NEXTINDEX*c,(e.NEXTINDEX+1)*c),e},_getCubicSpline(e,t,s,r){const n=t.INTERPOLATION,i=s[t.PREINDEX],a=s[t.NEXTINDEX];for(let s=0;s<3;s++){const o=t.PREVIOUS[r+s],f=(a-i)*t.PREVIOUS[2*r+s],u=t.NEXT[3+s],h=(a-i)*t.NEXT[s],c=(2*Math.pow(n,3)-3*Math.pow(n,2)+1)*o+(Math.pow(n,3)-2*Math.pow(n,2)+n)*f+(2*-Math.pow(n,3)+3*Math.pow(n,2))*u+(Math.pow(n,3)-Math.pow(n,2))*h;e[s]=c}return e},getAnimationClip(e,t,n,i){const a=e.nodes[t]&&e.nodes[t].weights;s.set(v,...M.TRANSLATION),r.set(q,...M.ROTATION),s.set(V,...M.SCALE);return this._getTRSW(i,e,t,n,v,q,V,a)},getTimeSpan(e){if(!e.animations)return null;if(e.timeSpan)return e.timeSpan;const t=e.animations;return e.timeSpan={},t.forEach((t,s)=>{let r=-1/0,n=1/0;const i=t.channels;for(let e=0;e<i.length;e++){const s=i[e],a=t.samplers[s.sampler].input.array;a[a.length-1]>r&&(r=a[a.length-1]),a[0]<n&&(n=a[0])}const a=t.name||s;e.timeSpan[a]={max:r,min:n}}),e.timeSpan},getTimeSpanByName(e,t){const s=this.getTimeSpan(e);return s?a(t)?s[t]:s[Object.keys(s)[0]]:null}};let D=!1;if("undefined"!=typeof OffscreenCanvas){let e;try{e=new OffscreenCanvas(2,2).getContext("2d")}catch(e){}e&&"undefined"!=typeof createImageBitmap&&(D=!0)}const C="undefined"==typeof document?null:document.createElement("canvas");class k{constructor(e,t,s){if(this.options=s||{},this.options.decoders||(this.options.decoders={}),t.buffer instanceof ArrayBuffer){const{json:s,glbBuffer:r}=A.read(t.buffer,t.byteOffset,t.byteLength);this._init(e,s,r)}else this._init(e,t);this._accessor=new E(this.rootPath,this.gltf,this.glbBuffer),this._checkExtensions()}_checkExtensions(){const e=this.gltf.extensionsRequired;if(e){if(e.indexOf("KHR_draco_mesh_compression")>=0&&!this.options.decoders.draco)throw new Error("KHR_draco_mesh_compression is required but @maptalks/transcoders.draco is not loaded");if(e.indexOf("KHR_texture_basisu")>=0&&!this.options.decoders.ktx2)throw new Error("KHR_texture_basisu is required but @maptalks/transcoders.ktx2 is not loaded")}}_loadExtensions(){const e=this.gltf.extensions;return e&&e.KHR_techniques_webgl?this._accessor.requestKHRTechniquesWebgl(e.KHR_techniques_webgl).then(t=>(e.KHR_techniques_webgl=t,e)):Promise.resolve(e)}load(e){e=e||{};const t=this._loadScene(e),s=this._loadAnimations(),r=this._loadTextures(),n=this._loadExtensions();return Promise.all([t,s,r,n]).then(e=>(e[0].animations=e[1],e[0].textures=e[2],e[0].extensions=e[3],e[0].transferables=this.transferables||[],this.createChannelsMap(e[0]),e[0]))}createChannelsMap(e){const t=e.animations;if(t)for(let e=0;e<t.length;e++){const s=t[e];s.channelsMap={};for(let e=0;e<s.channels.length;e++){const t=s.channels[e];s.channelsMap[t.target.node]||(s.channelsMap[t.target.node]=[]),s.channelsMap[t.target.node].push(t)}}}getExternalResources(){const e=[];if(this.gltf){const{buffers:t,images:s}=this.gltf;for(let s=0;s<t.length;s++)t[s].uri&&t[s].uri.indexOf("data:application/octet-stream;base64")<0&&e.push({type:"buffer",uri:t[s].uri});for(let t=0;t<s.length;t++)s[t].uri&&s[t].uri.indexOf("data:image/")<0&&e.push({type:"image",uri:s[t].uri})}return e}static getAnimationClip(e,t,s,r){return U.getAnimationClip(e,t,s,r)}static getAnimationTimeSpan(e,t){return U.getTimeSpanByName(e,t)}static getTypedArrayCtor(e){return f(e)}static readInterleavedArray(e,t,s,r,n,i,a){return b(e,t,s,r,n,i,a)}_init(e,t,s){this.gltf=t,this.glbBuffer=s,this.version=t.asset?+t.asset.version:1,this.rootPath=e,this.buffers={},this.requests={},this.options.requestImage=D?H.bind(this):this.options.requestImage||X,this.options.transferable&&(this.transferables=[]),2===this.version?(this.adapter=new O(e,t,s,this.options.requestImage,this.options.decoders||{},this.options.supportedFormats||{}),this.adapter.iterate((e,t,s)=>{t.id="buffer_"+s},"buffers"),this.adapter.iterate((e,t,s)=>{t.id="image_"+s},"images"),this.adapter.iterate((e,t,s)=>{t.id="accessor_"+s},"accessors")):(this.adapter=new I(e,t,s,this.options.requestImage,this.options.decoders||{},this.options.supportedFormats||{}),this.adapter.iterate((e,t,s)=>{t.id="accessor_"+s},"accessors"),this.adapter.iterate((e,t,s)=>{t.id="image_"+s},"images"))}_parseNodes(e,t){if(e.children&&e.children.length>0){if(!(s=e.children[0],"number"==typeof s&&isFinite(s)||function(e){return!i(e)&&("string"==typeof e||null!==e.constructor&&e.constructor===String)}(e.children[0])))return e;const r=e.children.map(e=>{const s=t[e];return s.nodeIndex=e,this._parseNodes(s,t)});e.children=r}var s;return e}_loadScene(e){return this._loadNodes(e).then(e=>{const t=this.scenes=[];let s;for(const t in e)e[t]=this._parseNodes(e[t],e),e[t].nodeIndex=Number(t)?Number(t):t;this.adapter.iterate((r,n,i)=>{const a={};n.name&&(a.name=n.name),n.nodes&&(a.nodes=n.nodes.map(t=>e[t])),this.gltf.scene===r&&(s=i),t.push(a)},"scenes");const r={asset:this.gltf.asset,scene:s,scenes:t,nodes:e,meshes:this.meshes,materials:this.gltf.materials,skins:this.skins};if(this.gltf.extensions&&(r.extensions=this.gltf.extensions),1===this.version){const e=this.adapter._loadMaterials(this.gltf.materials);r.materials=e}return r})}_loadNodes(e){return this._loadMeshes(e).then(()=>{const e=this.nodes={};return this.adapter.iterate((t,s)=>{const r=this.adapter.createNode(s,this.meshes,this.skins);e[t]=r},"nodes"),e})}_loadSkins(){this.skins=[];const e=[];return this.adapter.iterate((t,s,r)=>{e.push(this._loadSkin(s).then(e=>{e.index=r,this.skins.push(e)}))},"skins"),e}_loadSkin(e){const t=e.inverseBindMatrices;return this.adapter.accessor._requestData("inverseBindMatrices",t).then(t=>(e.inverseBindMatrices=t,t&&t.buffer&&this.transferables&&this.transferables.indexOf(t.buffer)<0&&this.transferables.push(t.buffer),e))}_loadAnimations(){const e=this.gltf.animations;return a(e)?this.adapter.getAnimations(e):null}_loadMeshes(e){this.meshes={};let t=[];return this.adapter.iterate((s,r,n)=>{t.push(this._loadMesh(r,e).then(e=>{e.index=n,this.meshes[s]=e}))},"meshes"),t=t.concat(this._loadSkins()),Promise.all(t)}_loadMesh(e,t){const s=e.primitives.map(e=>this._loadPrimitive(e,t)).filter(e=>!!e);return Promise.all(s).then(t=>{const s={};return o(s,e),s.primitives=t,s})}_loadTextures(){const e=this.gltf.textures;if(!e)return null;const t=[];for(const s in e)t.push(this.adapter._getTexture(s));return Promise.all(t).then(t=>{if(this.transferables)for(let e=0;e<t.length;e++){const s=t[e].image.array;if(t[e]&&s){let e;e=s instanceof ImageBitmap?s:s.buffer,e&&this.transferables.indexOf(e)<0&&this.transferables.push(e)}}if(!Array.isArray(e)){const s={},r=Object.keys(e);for(let e=0;e<t.length;e++)t[e]&&(s[r[e]]=t[e]);return s}return t})}_loadPrimitive(e,t){let r;const n=[],i=e.extensions;if(a(e.targets))for(let t=0;t<e.targets.length;t++){const s=e.targets[t];for(const e in s){const r=this.adapter.accessor._requestData(`morphTargets_${e}_${t}`,s[e]);r&&n.push(r)}}if(i&&i.KHR_draco_mesh_compression){if(!this.options.decoders.draco&&(!this.gltf.extensionsRequired||!this.gltf.extensionsRequired.indexOf("KHR_draco_mesh_compression")<0))return null;const e=this.options.decoders.draco,{bufferView:s,attributes:a}=i.KHR_draco_mesh_compression,o=this.gltf.bufferViews[s],f=this._accessor._requestBufferOfBufferView(o).then(s=>{const{buffer:r,byteOffset:n}=s;let{byteOffset:i,byteLength:f}=o;i||(i=0);const u=new DataView(r,n+i,f),h={attributes:a,useUniqueIDs:!1,skipAttributeTransform:t.skipAttributeTransform};return e(u,h).then(e=>{const t=Object.values(e.attributes);return e.indices&&t.push(e.indices),t})});n.push(f),r=Promise.all(n)}else{const t=e.attributes;for(const e in t){const s=this.adapter.accessor._requestData(e,t[e]);s&&n.push(s)}if(a(e.indices)){const t=this.adapter.accessor._requestData("indices",e.indices);t&&n.push(t)}r=Promise.all(n)}return r.then(t=>{if(i&&i.KHR_draco_mesh_compression){const s=e.targets?e.targets.length:0;t[s]=t[s].concat(t.slice(0,s)),t=t[s]}let r,n;const o={attributes:t.reduce((e,t)=>{if("indices"===t.name)r=t;else if(t.name.indexOf("morphTargets_")>-1)n=n||{},n[t.name.slice(13)]=t;else{if(!("POSITION"!==t.name||t.min&&t.max)){const e=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0],{itemSize:n,array:i}=t,a=i.length/n;for(let t=0;t<a;t++)for(let s=0;s<n;s++){const a=t*n+s;i[a]<e[s]&&(e[s]=i[a]),i[a]>r[s]&&(r[s]=i[a])}if(t.quantization){const n=t.quantization,i=n.range/(1<<n.quantizationBits),a=n.minValues;s.scale(e,e,i),s.add(e,e,a),s.scale(r,r,i),s.add(r,r,a)}t.min=e,t.max=r}e[t.name]=t}return this.transferables&&t.array.buffer&&this.transferables.indexOf(t.array.buffer)<0&&this.transferables.push(t.array.buffer),e},{}),material:e.material};return r&&(o.indices=r),n&&(o.morphTargets=n),o.mode=a(e.mode)?e.mode:4,a(e.extras)&&(o.extras=e.extras),o})}}function X(e,t){const s=new Image;s.crossOrigin="",s.onload=()=>{if(!C)return void t(new Error("There is no canvas to draw image!"));C.width=s.width,C.height=s.height;const e=C.getContext("2d");e.drawImage(s,0,0,s.width,s.height);const r=e.getImageData(0,0,s.width,s.height),n={width:s.width,height:s.height,data:new Uint8Array(r.data)};t(null,n)},s.onerror=function(e){t(e)},s.src=e}let j,F;function H(e,t){j||(j=new OffscreenCanvas(2,2),F=j.getContext("2d")),fetch(e).then(e=>e.arrayBuffer()).then(e=>{const t=new Blob([new Uint8Array(e)]);return createImageBitmap(t)}).then(e=>{let{width:s,height:r}=e;K(s)||(s=z(s)),K(r)||(r=z(r));const n=this.options.maxTextureSize;n&&(s=Math.min(n,s),r=Math.min(n,r)),j.width=s,j.height=r,F.drawImage(e,0,0,s,r),e.close();const i=F.getImageData(0,0,s,r);t(null,{width:s,height:r,data:new Uint8Array(i.data)})}).catch(e=>{console.warn(e),t(e)})}function K(e){return 0==(e&e-1)&&0!==e}function z(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}export{w as Ajax,k as GLTFLoader};
